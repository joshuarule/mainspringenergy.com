"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _react = _interopRequireWildcard(require("react"));

var _creatable = _interopRequireDefault(require("react-select/creatable"));

var _patchEvent = _interopRequireWildcard(require("part:@sanity/form-builder/patch-event"));

var _formBuilder = require("part:@sanity/form-builder");

var _client = _interopRequireDefault(require("part:@sanity/base/client"));

// @ts-nocheck
var createPatchFrom = value => _patchEvent.default.from(value === "" ? (0, _patchEvent.unset)() : (0, _patchEvent.set)(value));

var autocompleteTagsComponent = (0, _react.forwardRef)((props, ref) => {
  var [uniqueTags, setUniqueTags] = (0, _react.useState)([]);
  var [isLoading, setIsLoading] = (0, _react.useState)(false);
  var [selected, setSelected] = (0, _react.useState)([]); // TODO: This doesn't work, obviously :( Gotta fix it

  (0, _react.useImperativeHandle)(ref, () => ({
    focus() {
      this._inputElement.focus();
    }

  })); // We'll use this document type later to query and patch it

  var document = props.document._type; // On component load, let's fetch all tags from all images and only keep unique ones

  (0, _react.useEffect)(() => {
    // Component is loading! Hands off!
    setIsLoading(true); // Query for the document type and return the whole thing

    var query = "*[_type == '".concat(document, "'] { ... }");

    var fetchTags = /*#__PURE__*/function () {
      var _ref = (0, _asyncToGenerator2.default)(function* () {
        var allTags = [];

        _client.default.fetch(query).then(items => {
          items.forEach(item => {
            if (item.tags && item.tags.length > 0 && item.tags !== null) {
              // this could be a item?.tags?.length or something?
              allTags.push(item.tags);
            }

            return;
          }); // At this point, we have an array of arrays. Let's flatten this sucker!
          // @ts-ignore

          var flatTags = allTags.flat().filter(tag => {
            if (typeof tag !== "string") {
              return tag;
            }
          }); // Now, let's create a new array that only includes unique tags

          var uniqueTags = [];
          var map = new Map();

          for (var tag of flatTags) {
            if (!map.has(tag.value)) {
              map.set(tag.value, true);
              uniqueTags.push({
                value: tag.value,
                label: tag.label
              });
            }
          }

          setUniqueTags(uniqueTags);
        });
      });

      return function fetchTags() {
        return _ref.apply(this, arguments);
      };
    }(); // Ok, now let's populate the dropdown with tags already assigned.


    var setSelectedTags = /*#__PURE__*/function () {
      var _ref2 = (0, _asyncToGenerator2.default)(function* () {
        // populating existing tags from document props (this is why we need to set CDN to `false`: to make sure props have fresh set of tags)
        // let's make sure selected !== null and is always an array
        setSelected(!props.value ? [] : props.value);
      });

      return function setSelectedTags() {
        return _ref2.apply(this, arguments);
      };
    }();

    fetchTags();
    setSelectedTags(); // Component no longer loading

    setIsLoading(false);
  }, []); // Here we handle change to the tags when this change does not involve creating a new tag

  var handleChange = value => {
    // again, ensuring that `selected` remains an array
    setSelected(!value ? [] : value);
    props.onChange(createPatchFrom(!value ? [] : value));
  };
  /* 
  Ok, here's some fun: here we handle changes that involve creating new tags and populating these new options into selected tags and all tags
  */


  var createOption = inputValue => {
    var newSelected = selected;
    newSelected.push({
      value: inputValue,
      label: inputValue
    });
    setSelected(newSelected); // New tags need to be commited to Sanity so that we can reuse them elsewhere

    _client.default.patch(props.document._id).append(document, [{
      value: inputValue,
      label: inputValue
    }]).commit().then(() => props.onChange(createPatchFrom(newSelected)));
  };

  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement("h4", null, props.type.title), /*#__PURE__*/_react.default.createElement(_creatable.default, {
    disabled: isLoading,
    isLoading: isLoading,
    value: selected ? selected : [],
    isMulti: true,
    onChange: handleChange,
    onCreateOption: createOption,
    options: uniqueTags || ""
  }));
});

var _default = (0, _formBuilder.withDocument)(autocompleteTagsComponent);

exports.default = _default;